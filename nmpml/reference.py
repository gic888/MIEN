
## Copyright (C) 2005-2006 Graham I Cummins
## This program is free software; you can redistribute it and/or modify it under 
## the terms of the GNU General Public License as published by the Free Software 
## Foundation; either version 2 of the License, or (at your option) any later version.
## 
## This program is distributed in the hope that it will be useful, but WITHOUT ANY 
## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
## PARTICULAR PURPOSE. See the GNU General Public License for more details.
## 
## You should have received a copy of the GNU General Public License along with 
## this program; if not, write to the Free Software Foundation, Inc., 59 Temple 
## Place, Suite 330, Boston, MA 02111-1307 USA
## 
from mien.nmpml.basic_tools import NmpmlObject
from string import join

class ReferenceConversion(NmpmlObject):
	'''Class for reference point conversions
attrinbutes:
	Trans_x : Translation in the specified dimension, in the
	Trans_y   units of the owning ReferencePoint (not the
	Trans_z   target!).
    Rot_x   : Rotation counterclockwise around the specified axis
	Rot_y     in degrees (Rot_x=90 converts z to y,  y to -z)
	Rot_z
	Scale_x : Unitless multiplicative scale factor. Negative 
	Scale_y   values also implement mirror imaging.
	Scale_z
	Scale_d : Scale value applied to diameter for x,y,z,d points
	Order : comma separated list expressing the order of conversion,
	        using the words Rot, Trans, and Scale (e.g. "Scale,Rot,Trans").			
'''
	_requiredAttributes =['Name',
						  'Trans_x',
						  'Trans_y',
						  'Trans_z',
						  'Rot_x',
						  'Rot_y',
						  'Rot_z',
						  'Scale_x',
						  'Scale_y',
						  'Scale_z',
						  'Scale_d',
						  'Order']
	_guiConstructorInfo={"Name":{"Name":'Name',
								 "Value":"RefConv"},

						 "Trans_x":{"Name":'Trans_x',
									"Value":0.0},
						 'Trans_y':{"Name":'Trans_y',
									"Value":0.0},
						 'Trans_z':{"Name":'Trans_z',
									"Value":0.0},
						 'Rot_x':{"Name":'Rot_x',
								  "Value":0.0},
						 'Rot_y':{"Name":'Rot_y',
								  "Value":0.0},
						 'Rot_z':{"Name":'Rot_z',
								  "Value":0.0},
						 'Scale_x':{"Name":'Scale_x',
									"Value":1.0},
						 'Scale_y':{"Name":'Scale_y',
									"Value":1.0},
						 'Scale_z':{"Name":'Scale_z',
									"Value":1.0},
						 'Scale_d':{"Name":'Scale_d',
									"Value":1.0},
						 'Order':{"Name":'Order',
								  "Value":'Trans,Rot,Scale'}}
	_allowedChildren = ["Comments", "ElementReference"]
	
	__tag__="ReferenceConversion"

	def target(self):
		'''returns self.attributes["ReferencePoint"]'''
		er = self.getElements("ElementReference")[0]
		return er.target()

	def conversion(self):
		'''No Args => dict
return a conversion dictionary. This is basically a copy of self.attributes,
except the values of the numerical keys are converted to float type. "Order"
is converted to list type.'''
		d = {}
		for k in self.attributes.keys():
			if k == "Name":
				continue
			if k == "Order":
				d[k]=self.attributes[k].split(',')
			else:
				d[k]=float(self.attributes[k])
		return d

	def inverse_conversion(self):
		'''No Args => dict
returns a conversion dict suitable to reverse the conversion generated by self.conversion'''
		d = {}
		for k in self.attributes.keys():
			if k.startswith("Rot"):
				d[k]=-1*float(self.attributes[k])
			elif k.startswith("Trans"):
				d[k]=-1*float(self.attributes[k])
			elif k.startswith("Scale"):
				d[k]=1.0/float(self.attributes[k])
			elif k == "Order":
				d[k]=self.attributes[k].split(',')
		return d		

class ReferencePoint(NmpmlObject):
	'''Data type to represent a fixed point of reference, and conversion
information for other points of reference.
members:
    As Parent Class
attributes:
    Name (str) : A unique ID. No two ReferencePoints in the same network
	             can have the same name. The name should be descriptive,
				 but should not contain special characters or space.
				 e.g. "CricketCercalXHairNoShrinkageCorrection"
	Units (str) : The units of measurment. All coordinates and
	              distances claiming this ReferencePoint have
				  these units. The value should be a string
				  understood by the Unix "units" command.

'''
	_allowedChildren = ["ReferenceConversion", "Comments"]
	_requiredAttributes = ["Name", "Units"]

	def getConversion(self, rp):
		'''rp (ReferencePoint or path) = > Tuple or None
try to find a conversion to the specified reference point (an instance or
xmodpath)'''
		refp=None
		if type(rp)!=str:
			refp = rp
			rp = rp.upath()
		for c in self.getElements('ReferenceConversion'):
			if c.target() == rp:
				return c.conversion()
		if not refp:
			refp=sef.getInstance(rp)
		for c in refp.getElements('ReferenceConversion'):
			if c.target() == self.upath():
				return c.inverse_conversion()
		return None	

ELEMENTS={"ReferencePoint":ReferencePoint,
		  "ReferenceConversion":ReferenceConversion}
